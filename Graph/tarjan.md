# $Tarjan$ 算法（一）: 求强连通分量
------
## 强连通分量

> 有向图强连通分量：在有向图G中，如果两个顶点$vi, vj$间($v_i>v_j$)有一条从$v_i$到$v_j$的有向路径，同时还有一条从$v_j$到$v_i$的有向路径，则称两个顶点强连通(strongly connected).如果有向图$G$的每两个顶点都强连通，称$G$是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components).

------

## 算法详解
简介：

> Tarjan算法是基于对图深度优先搜索的算法，每个强连通分量为搜索树中的一棵子树。搜索时，把当前搜索树中未处理的节点加入一个堆栈，回溯时可以判断栈顶到栈中的节点是否为一个强连通分量。Tarjan算法有点类似于基于后序的深度遍历搜索和并查集的组合，充分利用回溯来解决问题。

该算法维护三个数组:

- $dfn[i]$：深度优先搜索遍历时节点i被搜索的次序。
- $low[i]$：节点i能够回溯到的最早位于栈中的节点。
- $ins[i]$：标记点i是否在栈中。

**步骤:**

- 传入顶点$u$, 将$u$入栈, 并且$dfn[u] = low[u] = idx++$ *(设定次序编号，和 $low[u]$ 初值)*
- 枚举顶点$v$与$u$连通:
    - 如果$v$没有处理过 ($dfn[v]=0$) *($dfn$ 即是 $dfs$ 序，值不为零就表示访问过了)*
        - 那么$Tarjan(v)$ 并且 $ins[i]:=true$.
        - 如果$low[u]>low[v]$ 那么$low[u]:=low[v]$ *(因为访问以$v$为顶点的子树时找到的比当前$v$能找到节点更小的祖先，即$v$在一个以另一个点为根的强连通分量中)*
    - 在栈里 ($ins[v]=true$) (说明访问过，并且还在栈中)
        - 如果$low[u]>dfn[v]$ 那么$low[u]:=dfn[v]$ *($v$可能是祖先，而不是一个极大强连通分量里的一个小分量的根)*
- 然后，如果$low[u]=dfn[u]$: (说明$u$是一个强联通分量的根)
    - 将栈中所有在$v$之前的点$u$弹出. *(由于该连通图中的$dfn$值和$low$值相等的节点是该连通图中第一个被访问到的节点，又根据栈的特性，则该节点在最里面。所以能够通过不停的弹栈，直到弹出该$dfn$值和$low$值相同的节点来弹出该连通图中所有的节点。)*

**代码:**

```c++
void tarjan(int u) {
     int v;
     dfn[u] = low[u] = ++idx; //每次dfs，u的次序号增加1
     s.push(u);//将u入栈
     ins[u] = 1;//标记u在栈内
     for(int i = head[u]; ~i; i = e[i].next) { //访问从u出发的边
         v = e[i].v;
         if (!dfn[v]) { //如果v没被处理过
             tarjan(v); //dfs(v)
             low[u] = min(low[u], low[v]); //u点能到达的最小次序号是它自己能到达点的最小次序号和连接点v能到达点的最小次序号中较小的
         }
         else if (ins[v])
            low[u] = min(low[u], dfn[v]); //如果v在栈内，u点能到达的最小次序号是它自己能到达点的最小次序号和v的次序号中较小的
     }     
     if(dfn[u] == low[u]) {
         scc++;
         while(u != v) {
             v = s.top();
             s.pop();
             ins[v] = 0;
             Belong[v] = scc;
         }
     }
}
```

**Tips:**
* 记录后的 $Belong[]$ 数组以后可以用于查询，重建图等操作。
* 不要将$v$进一步处理的条件弄混了：是 $dfs[v]=0$ 而不是 $ins[v]=0$, 所以不建议将 $ins[]$ 数组命名为 $vis[]$, 容易引起歧义或误解。
